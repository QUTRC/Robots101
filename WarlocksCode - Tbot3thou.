# Code to display picam as a video stream, does not save, is a raw feed. - Source code started: 4th Sept 2022 created by TheWarlock27
import cv2
import numpy as np
import time
import picamera #Picam info: The sensor itself has a native resolution of 5 megapixel, and has a fixed focus lens onboard. In terms of still images, the camera is capable of 2592 x 1944 pixel static images, and also supports 1080p @ 30fps, 720p @ 60fps and 640x480p 60/90 video recording.
from math import atan,sin,cos,pi,floor
import imutils
from picamera import Picamera, colour
from picamera.array import PiRGBArray

#-------------------------------------------------------------------------- Complete code: Picam Video Livefeed - By TheWarlock27
# Code to display picam as a video stream, does not save, is a raw feed. - Source code started: 4th Sept 2022 created by TheWarlock27

import cv2
import numpy as np
import time
import picamera #Picam info: The sensor itself has a native resolution of 5 megapixel, and has a fixed focus lens onboard. In terms of still images, the camera is capable of 2592 x 1944 pixel static images, and also supports 1080p @ 30fps, 720p @ 60fps and 640x480p 60/90 video recording.
from math import atan,sin,cos,pi,floor
import imutils
from picamera import PiCamera
from picamera.array import PiRGBArray

#camera = PiCamera()
cap = cv2.VideoCapture(0)
#camera.resolution = (1280, 720)
#time.sleep(2)

if (cap.isOpened()== False):  #Check if camera opened successfully
  print("Error opening video stream or file")

while(cap.isOpened()):   #Read until video is completed
  ret, frame = cap.read()   #Capture frame-by-frame
  if ret == True:
    cv2.imshow('Stream',frame)      # Display the resulting frame
    print ("streaming")
    if cv2.waitKey(25) & 0xFF == ord('q'):      # Press lowercase Q on keyboard to exit
        break
  else: 
    print("No Feed")
    break     #Break the loop

cap.release()  # When everything done, release the video capture object
cv2.destroyAllWindows()  # Closes all the frames



#----------------------------------------------------------------------------- #takes a picture and saves it

#Takes a picture and stores picture on computer file
from picamera import PiCamera
import cv2

camera = PiCamera()
rawCapture = PiRGBArray(camera)
camera.resolution = (2592, 1944)
time.sleep(200)
camera.capture(rawCapture, format="bgr")
stream = rawCapture.array
camera.capture("/home/qutrc/Desktop/Robots101/Warlock27/Robots101/img.jpg")  #This line saves the capture, Optional to do so.
print("Done.")

cv2.waitKey(0) 
cv2.destroyAllWindows() 

#-------------------------------------------------------------------------- Experimental Code. Incomplete, This requires luke to review.


cv2.imshow() #shows the / returns the captured video / frames
waitkey(1) #show the captured feed for a number in miliseconds, 0 is infinite time (a picture)

kernel = np.ones((4,4))                             # Define variable for image noise filtering (covered more later)
with picamera.PiCamera() as camera:                 # Start up the picamera using the PiCamera library. For pi4s this may be a bit out of date and the libcamera library is potentially better. For the 3B+ Pis we are using they're great.
    camera.resolution = (640, 480)                  # Currently the only setting I'm changing. With weaker/stronger pis you may have to decrease or increase this. 

def cam_setup():
    cap = cv2.VideoCapture(0)                       # Connect to camera 0, this is the camera slot you plugged the camera into
    cap.set(3,480)                                  # set width of the image to 480
    cap.set(4,640)                                  # set the height to 640
return cap                                          # Return the camera object to use with the rest of the code. OpenCV - does it display the output feed? (Ask club members)

#Read OpenCV documentation to ensure correct use of filtering code. Code previous to this line should run.
#---------------------------------------

while(True):
    ret, frame = cap.read()  # Capture frame-by-frame
    
    # Our operations on the frame come here - line 16 should convert feed to greyscale.
    # gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)     # Our operations on the frame come here

    # Display the resulting frame
    cv2.imshow('RGB',gray)
   
   
   

        cv2.imshow('Orig_img',frame)             
        cv2.imshow('hsv_img' ,hsv_frame)
        cv2.imshow('binary', binary_image)
        cv2.imshow('filtered', filtered)
   
    if cv2.waitKey(25) & 0xFF == ord('q'):      # Press lowercase Q on keyboard to exit
      break
cap.release()
cv2.destroyAllWindows()



#----------- Code pool, courtesy of Luke


def get_frame(frame):     #This function gets passed a frame, and prepares it to be blurred and put into the correct colour space. 
    hsv_frame = cv2.cvtColor(frame, None)           # Change the colour space using the cvtColor function
                                                    # <Insert OpenCV colour code for converstion>
    return None                                     # Return both the frame and the HSV_frame. You only need the original frame if you intend to draw on it (like bounding boxes, frame rates, etc.)


def find_objects(hsv_frame, frame=None):            #Implement the main image processing pipeline for finding objects. Takes the hsv_frame (and optionally the original frame if you wish to draw on it)
    
    lower_bound = (None,None,None)                  # The lower and upper bound for your inRange function. This is the pixel data range that you consider to be indicative of an object.
    upper_bound = (None,None,None)                  # (h,s,v)
                                                    # (h,s,v)
                                                    
    binary_image = cv2.inRange(None,None,None)      # Create a "binary image" using your colour space ranges. Anything inside the range specified will be assigned a 1 and anything outside will be a 0 in terms of the image data.
                                                    # Look at the inRange documentation for openCV for instructions on how to use this image
                                                    # To display your result so far, comment everything below this point and use the "imshow" function. Usage of this function can be found in the OpenCV documentation.
                                                    
    filtered = cv2.morphologyEx(None, None, None)   # Now filter out all the noise in your image using the kernel specified at the top of your code. You will want to dilate and close the model. 
                                                    # There is a morphologyEx operation that does both of these things. Experiment with different kernel sizes and morphology operations to see how your image gets filtered
                                                    # To display your result so far, comment everything below this point and use the "imshow" function. Usage of this function can be found in the OpenCV documentation.
                                                    
                                                    # At this point you will have a nice 'mask' showing your object. Feel free to take things further using the contours function and starting to research methods of doing distance and angle measurements to your identified objects!
                                                    
    return None, None                               # Return the information you want to return (This could be the filtered image, the binary image, the distance to objects or angle to objects. Whatever your program needs at the current time.)



# This if statement protects your main loop and will not execute it if you call this file as a library. When you run a file, it is given the name "__main__" but when it is imported as a library
# it is not. This means this file is set up to be safely called as a library.
if __name__ == "__main__":
    cap = cam_setup()                               # Initialise the camera object to start a new video feed outside the loop
    while True:                                     # This would normally be a really bad idea but we have 2 break statements in this loop that allow it to exit.
        key = cv2.waitKey(None)                     # This function gives you the ability to add a small delay (in miliseconds) and it will try to detect you pressing a keyboard key. (e.g. an 'a' or a 'h')
        ret, frame = cap.read()                     # ret is a boolean that returns True when an image was successfully returned and False when it failed to read an image.
        if not ret:
            break
        start = time.time()                                         # Using the time library to calculate framerate and show performance
        None = get_frame(frame)                                     # Return the frame
        None, None = find_objects(hsv_frame, frame)                 # Use the frame to find objects
        None = 1/(time.time() - start)                              # Just framerate things
        cv2.putText(frame, 'Framerate: %05.3f' %(Framerate) ,       # Draw the framerate on the original image
        (20,20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255), 1)   
        

